<!doctype html> <html lang="en">   <head>     <script type="text/javascript"
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css"> <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script> 

        <meta charset="utf-8">         <meta http-equiv="x-ua-compatible" content="ie=edge">         <meta name="viewport" content="width=device-width, initial-scale=1">         <title> Archives</title>         <link rel="stylesheet" href="../css/default.css" />     </head>     <body>         <header>             <div class="logo">                 <a href="../">~dave's blog~</a>             </div>             <nav>                  <a href="../index.html">home</a>                 <a href="../about.html">about</a>                 <a href="../archive.html">posts</a>             </nav>         </header><h1>Leetcode 55 In 31 Characters Of BQN</h1><p>Good ol' <a href="https://leetcode.com/problems/jump-game/">Leetcode 55</a>, a classic in the interview circuit. At first glance, it's a simple question with a straightforward solution - just simulate the game, jump from the start index to each reachable index and see if we can reach the end. This leads to an O(n^2) solution and inevitably to the follow up question: "but can you do it in linear time?".</p><p>This proves deceptively difficult. Deceptive because the linear solution is (like most leetcode problems) simple. But unless you've seen similar problems (or, you already know the "trick") you're bound to waste valuable interview time teasing out the solution. But once the answer strikes you (or you look it up), you'll either kick yourself for missing something so obvious or pat yourself on the back for seeing through the interviewer's ruse.</p><p>Here's the idea, it's a basic dynamic programming solution:</p><p>Let x = array[0] and at each index (i) calculate x = max(x-1, array[i]).</p><p>If x == 0 at or before the end of the array then we know we won't make it and we should return false.</p><p>Following this recipe will get us an O(N) solution, which is normally ~10 lines of Python, but we can do it in just one line (32 characters!) of <a href="https://mlochbaum.github.io/BQN/index.html">BQN</a> (presumably, we could also do it in one line in most other array languages, and Python list comprehensions will probably also get you close).</p><pre><code>Jumpgame â† {aâ† âŠ‘ğ•© , (Ã—Â´ {a â‰¤ ğ•© ? aâ†©ğ•©; aâ†©a-1}Â¨ ğ•©) â‰¢ 0}

</code></pre><p>We can run this block as follows</p><pre><code>Jumpgame âŸ¨0,2,1âŸ©
-&gt;		 0
Jumpgame âŸ¨ 2, 3, 1, 1, 4 âŸ©
-&gt;		 1 
</code></pre><p>BQN doesn't exactly have the boolean value types True and False, instead they're represented naturally by 1 and 0.</p><p>BQN is interepreted from right to left, but I'll walk through the code from right to left.</p><pre><code>Jumpgame â† {aâ† âŠ‘ğ•© , 
</code></pre><p>We define Jumpgame as a block (which in this case, will behave as a function) that captures the value of the first index as the variable a, then we proceed to the second, inner block using the ',' seperator.</p><pre><code>{a â‰¤ ğ•© ? aâ†©ğ•©; aâ†©a-1}Â¨ ğ•©
</code></pre><p>The inner block performs the algorithm discussed above. We use the previously defined variable a, and a variable that will be bound to the argument on the right side of the block, captured by ğ•©. The diaresis (Â¨) at the end of this block means "Each", resulting in the function being performed over each element , i.e., mapped over the given list. This results in a new array with the value max(x-1,array[i]) at each index i.</p><pre><code>(Ã—Â´ {a â‰¤ ğ•© ? aâ†©ğ•©; aâ†©a-1}Â¨ ğ•©) â‰¢ 0}
</code></pre><p>By product folding this array (x' means fold by multiplying each element the list with the next element) and comparing the result with 0, we get our answer - can we reach the end or not? 0 means that there's a 0 somewhere in the array, so, no we can't. 1 means yes we can reach the end.</p><p>Admittedly, you could probably code golf this down quite a bit further. But I think this solution is fine as is, and as a bonus, it's surprisingly readable for an array language!</p>         <footer>             Site proudly generated by rackle . <a href="../feed.rss">rss</a>         </footer>     </body> </html> 